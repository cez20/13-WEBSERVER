DESCRIPTION DU PROJET:
- Ecrire votre propre serveur HTTP
- Il faut suivre la RFS d'HTTP qui permettra de tester avec
    vrai browser web
- Protocole HTTP : connaitre son fonctionnement

INTRODUCTION:
[] HTTP (HyperText Transfer Protocol)


TODO: Consignes generales:
[] Programme NE DOIT PAS crash, meme si a court de memoire
[] Rendre un Makefile qui compilera les fichiers sources.
  [] Makefile ne doit pas relink
  [] Makefile doit contenir au minimum les regles suivantes:
    [] $(NAME), all, clean, fclean, re
[] Compiler le code avec compilateur (c++) et les flags -Wall -Wextra -Werror
  [] Ajouter le flag -std=c++98
[] Utiliser en priorite des fonctionnalites C++
  []Ex: <cstring> au lieu de <string.h>
[] Tout usage de bibliotheque externe ou de l'ensemble Boost estINTERDIT

TODO: Partie obligatoire (Regarder PDF pour les fichier requis obligatoire¨)
[] Ecrire un serveur HTTP en C++98
[] Votre binaire doit etre appele comme ceci
  [] ./webserv [configuration file]
[] Bien que poll() soit mentionne dans le sujet et la grille d'evaluation
    , vous pouvez utiliser un equivalent tel que select(), kqueue(), ou epoll()
[] Veuillez lire la RFS et faire quelques tests avec telnet et NGINX
   avant de commencer ce projet. Meme si vous n'avez pas a implementer toute la RFS, cela
   vous aidera a developper les fonctionnalites requises.


TODO: Prerequis
[] Votre programme doit prendre un fichier de configuration en argument OU¨
    utiliser un chemin par defaut
[] Vous ne pouvez pas executer un autre serveur web
[] Votre serveur ne doit JAMAIS bloquer et le client doit etre correctement renvoyer
    si necessaire
  [] Il doit etre NON-BLOQUANT
  [] Il doit n'utiliser qu'un seul poll() ou (equivalent) pour toutes les
      operations entrees/sorties entre le client et le serveur (listen inclus)
[] poll()  (ou equivalent) doit verifier la lecture ou une operation d'ecriture
    sans passser par poll() (ou equivalent)
[] Vous ne devriez jamais faire une operation de lecture ou une operation d'ecriture
   sans passer par poll() ou equivalent
[] La verification de la valeur de errno est strictement interdite apres
    une operation de lecture ou d'ecriture
[] Vous n'avez pas besoin d'utiliser poll() (ou equivalent) avant de lire
    votre fichier de configuration
    [] Comme vous pouvez utiliser des FD en mode non-bloquant, il est possible
       d'avoir un serveur non bloquant avec read/recv ou write/send
       tout en n'ayant pas recours a poll() (ou equivalent).
       Mais cela consommerait des ressources systeme inutilement.
       Ainsi, si vous essayez d'utiliser read/recv ou write/send avec
       n'importe quel FD sans utiliser poll() (ou equivalent), votre
       notre sera de 0
[] Vous pouvez utiliser chaque macro et definir comme FD_SET, FD_CLR,
  FD_ISSET, FD_ZERO (comprendre ce qu'elles font et comment elles le font
  est tres utile)
[] Une requete a votre serveur ne devrait jamais se bloquer pour indefiniment
[] Votre serveur doit être compatible avec le navigateur web de votre choix.
[]Nous considérerons que NGINX est conforme à HTTP 1.1 et peut être utilisé pour
comparer les en-têtes et les comportements de réponse
[] Vos codes d’état de réponse HTTP doivent être exacts
[] Votre serveur doit avoir des pages d’erreur par défaut si aucune n’est fournie.
[] Vous ne pouvez pas utiliser fork pour autre chose que CGI (comme PHP ou Python,
etc).
[] Vous devriez pouvoir servir un site web entièrement statique.
[] Le client devrait pouvoir télécharger des fichiers.
[] Vous avez besoin au moins des méthodes GET, POST, et DELETE
[] Stress testez votre serveur, il doit rester disponible à tout prix.
[] Votre serveur doit pouvoir écouter sur plusieurs ports (cf. Fichier de configuration).


TODO: pour MacOS seulement

[] Vu que MacOS n'implemente pas write() comme les autres Unix, vous
   pouvez utiliser fcntl().Vous devez utiliser des descripteurs de fichier en mode non-bloquant
   afin d'obtenir un resultat similaire a celui des autres Unix
[] Toutefois, vous ne pouvez utiliser fcntl() que de la facon suivante:
    fcntl(fd, F_SETFL, O_NONBLOCK)
    Tout autre flag est interdit


TODO: Fichier de configuration 

[] ***VOUS POUVEZ VOUS INSPIRER DE LA PARTIE "SERVEUR" DU FICHIER DE
   CONFIGURATION NGINX

Dans de fichier de configuration, vous devez pouvoir:
[] Choisir le port et l'host de chaque "serveur"
[] Setup server_names ou pas
[] Le premier serveur pour un host:port sera le serveur par defaut
   pour cet host:port (ce qui signifie qu'il repondra a toutes les requetes
   qui n'appartiennent pas a une autre serveur)
[] Setup des pages d’erreur par défaut.
[] Limiter la taille du body des clients.
[] Setup des routes avec une ou plusieurs des règles/configurations suivantes (les
routes n’utiliseront pas de regexp) :
  [] Définir une liste de méthodes HTTP acceptées pour la route.
  [] Définir une redirection HTTP
  [] Définir un répertoire ou un fichier à partir duquel le fichier doit être recherché
     (par exemple si l’url /kapouet est rootée sur /tmp/www, l’url /kapouet/pouic/toto/pouet
      est /tmp/www/pouic/toto/pouet).
  [] Activer ou désactiver le listing des répertoires
  [] Set un fichier par défaut comme réponse si la requête est un répertoire
  [] Exécuter CGI en fonction de certaines extensions de fichier (par exemple .php).
  [] Faites-le fonctionner avec les méthodes POST et GET.
  [] Rendre la route capable d’accepter les fichiers téléchargés et configurer où cela
      doit être enregistré.
      [] Vous vous demandez ce qu’est un CGI ?
      [] Parce que vous n’allez pas appeler le CGI mais utiliser directement le chemin
        complet comme PATH_INFO.
      [] Rappelez-vous juste que, pour les requêtes fragmentées, votre serveur a
          besoin de la découper, le CGI attendra un EOF à la fin du body.
      [] Même choses pour la sortie du CGI. Si aucun content_length n’est renvoyé
        par le CGI, EOF signifiera la fin des données renvoyées.
      [] Votre programme doit appeler le CGI avec le fichier demandé comme premier
          argument.
      [] Le CGI doit être exécuté dans le bon répertoire pour l’accès au fichier de
          chemin relatif.
      [] votre serveur devrait fonctionner avec un seul CGI (php-CGI, Python, etc.).

  [] Vous devez fournir des fichiers de configuration et des fichiers de base par défaut pour
      tester et démontrer que chaque fonctionnalité fonctionne pendant l’évaluation.
    [] Si vous avez une question sur un comportement, vous devez comparer le
      comportement de votre programme avec celui de NGINX.
      Par exemple, vérifiez le fonctionnement du server_name.
      Nous avons partagé avec vous un petit testeur. Il n’est pas
      obligatoire de le réussir à la perfection si tout fonctionne bien
      avec votre navigateur et vos tests, mais cela peut vous aider à
      résoudre certains bugs.
    [] L’important, c’est la résilience. Votre serveur ne devrait jamais
        mourir. 
    [] Ne testez pas avec un seul programme. Écrivez vos tests avec un
      langage comme Python ou Golang, etc... Vous pouvez même les faire en
      C ou C++.